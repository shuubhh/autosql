name: $(Date:yyyyMMdd)$(Rev:.r)

trigger: none # Manual trigger only

parameters:
- name: sqlScriptName
  displayName: 'SQL Script Name'
  type: string
  default: 'script.sql'
- name: dryRun
  displayName: 'Dry Run (Validation Only)'
  type: boolean
  default: false
- name: enableBackup
  displayName: 'Enable Backup Before Execution'
  type: boolean
  default: true
- name: agentPool
  displayName: 'Agent Pool'
  type: string
  default: 'self1'

variables:
  sqlScriptPath: '$(Pipeline.Workspace)/sql/${{ parameters.sqlScriptName }}'
  backupPath: '$(Pipeline.Workspace)/backup'
  logsPath: '$(Pipeline.Workspace)/logs'
  storageAccountName: 'sqlautostacc'
  containerName: 'rawsql'
  backupContainerName: 'backups'
  keyVaultName: 'sql-validator-kv'
  secretName: 'sql-conn-string'

stages:
- stage: Download_And_Validate
  displayName: 'Download and Validate SQL Script'
  jobs:
  - job: DownloadScript
    displayName: 'Download SQL Script from Blob Storage'
    pool:
      name: ${{ parameters.agentPool }}
    timeoutInMinutes: 10
    
    steps:
    - checkout: none
    
    - task: PowerShell@2
      displayName: 'Verify Agent Prerequisites'
      inputs:
        targetType: 'inline'
        script: |
          Write-Host "Checking agent prerequisites..."
          
          # Check PowerShell version
          $psVersion = $PSVersionTable.PSVersion
          Write-Host "PowerShell Version: $psVersion"
          if ($psVersion.Major -lt 5) {
              Write-Error "PowerShell 5.0 or higher required"
              exit 1
          }
          
          # Check Python
          try {
              $pythonVersion = python --version 2>&1
              Write-Host "Python: $pythonVersion"
              
              # Check if sqlparse is installed
              $sqlparseCheck = python -c "import sqlparse; print('sqlparse is available')" 2>&1
              if ($LASTEXITCODE -ne 0) {
                  Write-Host "Installing sqlparse module..."
                  python -m pip install sqlparse==0.4.4
              } else {
                  Write-Host "✓ sqlparse module is already installed"
              }
          } catch {
              Write-Error "Python not found or not working properly. Please ensure Python 3.x is installed and in PATH"
              Write-Host "Available Python versions:"
              Get-Command python* -CommandType Application | Format-Table Name, Path
              exit 1
          }
          
          # Check Az PowerShell module
          $azModule = Get-Module -ListAvailable -Name Az.Accounts, Az.KeyVault, Az.Storage
          if (-not $azModule) {
              Write-Host "Installing Az PowerShell modules..."
              Install-Module -Name Az.Accounts, Az.KeyVault, Az.Storage -Force -AllowClobber -Scope CurrentUser
          }
          
          # Check SqlServer module
          $sqlModule = Get-Module -ListAvailable -Name SqlServer
          if (-not $sqlModule) {
              Write-Host "Installing SqlServer PowerShell module..."
              Install-Module -Name SqlServer -Force -AllowClobber -Scope CurrentUser
          }
          
          Write-Host "✓ Prerequisites verified"

    - task: AzurePowerShell@5
      displayName: 'Download SQL Script from Blob'
      inputs:
        azureSubscription: 'Azure-Connection'
        ScriptType: 'InlineScript'
        azurePowerShellVersion: 'LatestVersion'
        Inline: |
          $ErrorActionPreference = "Stop"
          
          try {
              Write-Host "Creating directory structure..."
              New-Item -ItemType Directory -Force -Path "$(Pipeline.Workspace)/sql" | Out-Null
              
              Write-Host "Downloading script: ${{ parameters.sqlScriptName }}"
              
              # Get storage account context
              $storageAccount = Get-AzStorageAccount | Where-Object { $_.StorageAccountName -eq "$(storageAccountName)" }
              
              if (-not $storageAccount) {
                  throw "Storage account '$(storageAccountName)' not found"
              }
              
              $ctx = $storageAccount.Context
              
              # Download blob
              Get-AzStorageBlobContent `
                  -Container "$(containerName)" `
                  -Blob "${{ parameters.sqlScriptName }}" `
                  -Destination "$(sqlScriptPath)" `
                  -Context $ctx `
                  -Force
              
              if (-not (Test-Path "$(sqlScriptPath)")) {
                  throw "Failed to download SQL script"
              }
              
              $fileSize = (Get-Item "$(sqlScriptPath)").Length
              Write-Host "✓ Script downloaded successfully ($fileSize bytes)"
              Write-Host "Script location: $(sqlScriptPath)"
              Get-Content "$(sqlScriptPath)" -TotalCount 5 | ForEach-Object { Write-Host "  $_" }
          }
          catch {
              Write-Error "Download failed: $($_.Exception.Message)"
              exit 1
          }

    - task: PublishPipelineArtifact@1
      displayName: 'Publish SQL Script'
      inputs:
        targetPath: '$(Pipeline.Workspace)/sql'
        artifact: 'SQLScript'
        publishLocation: 'pipeline'

  - job: ValidateScript
    displayName: 'Syntax and Security Validation'
    dependsOn: DownloadScript
    pool:
      name: ${{ parameters.agentPool }}
    timeoutInMinutes: 15
    
    steps:
    - checkout: none
    
    - task: DownloadPipelineArtifact@2
      displayName: 'Download SQL Script Artifact'
      inputs:
        artifact: 'SQLScript'
        path: '$(Pipeline.Workspace)/sql'

    - task: PythonScript@0
      name: SQLValidation
      displayName: 'SQL Syntax and Security Validation'
      inputs:
        scriptSource: 'inline'
        script: |
          import sqlparse
          import sys
          import os
          import re
          import json
          
          # Debug: Print environment variables and check paths
          print("=== DEBUG INFORMATION ===")
          print("Environment Variables:")
          for key, value in sorted(os.environ.items()):
              if any(term in key for term in ['WORK', 'AGENT', 'PIPELINE', 'BUILD', 'SCRIPT', 'SYSTEM']):
                  print(f"  {key}: {value}")
          
          # Get paths from environment variables
          pipeline_workspace = os.environ.get('PIPELINE_WORKSPACE')
          sql_script_path = os.environ.get('SQL_SCRIPT_PATH')
          
          print(f"\nPipeline Workspace from env: {pipeline_workspace}")
          print(f"SQL Script Path from env: {sql_script_path}")
          
          # If environment variables are not set, try alternative approaches
          if not pipeline_workspace:
              print("PIPELINE_WORKSPACE not found in environment, trying alternatives...")
              possible_workspaces = [
                  os.environ.get('AGENT_WORKFOLDER'),
                  os.environ.get('SYSTEM_DEFAULTWORKINGDIRECTORY'),
                  os.path.abspath('.')
              ]
              for workspace in possible_workspaces:
                  if workspace and os.path.exists(workspace):
                      pipeline_workspace = workspace
                      print(f"Using alternative workspace: {pipeline_workspace}")
                      break
          
          if not sql_script_path:
              print("SQL_SCRIPT_PATH not found in environment, constructing path...")
              if pipeline_workspace:
                  sql_script_path = os.path.join(pipeline_workspace, 'sql', 'script.sql')
                  print(f"Constructed script path: {sql_script_path}")
          
          # Normalize paths
          if pipeline_workspace:
              report_dir = os.path.join(pipeline_workspace, 'sql')
          else:
              report_dir = 'sql'  # Fallback
              
          script_path = sql_script_path
          
          print(f"\nFinal Paths:")
          print(f"Report Directory: {report_dir}")
          print(f"Script Path: {script_path}")
          
          # Check if script file exists
          print(f"\nFile Check:")
          print(f"Script exists: {os.path.exists(script_path) if script_path else 'No path'}")
          if script_path and os.path.exists(script_path):
              print(f"Script size: {os.path.getsize(script_path)} bytes")
              # Show first few lines of the script
              try:
                  with open(script_path, 'r', encoding='utf-8') as f:
                      first_lines = []
                      for _ in range(5):
                          line = f.readline()
                          if not line:
                              break
                          first_lines.append(line.strip())
                  print(f"First lines: {first_lines}")
              except Exception as e:
                  print(f"Error reading script: {e}")
          else:
              # List files in possible locations
              print("Searching for SQL files...")
              search_dirs = [pipeline_workspace, 'sql', '.', os.path.join(pipeline_workspace, 'sql') if pipeline_workspace else 'sql']
              for search_dir in search_dirs:
                  if search_dir and os.path.exists(search_dir):
                      print(f"Files in {search_dir}:")
                      try:
                          for file in os.listdir(search_dir):
                              if file.endswith('.sql'):
                                  print(f"  - {file}")
                      except Exception as e:
                          print(f"  Error listing: {e}")
          
          print("=== END DEBUG ===\n")
          
          # Validate that we have a script path
          if not script_path or not os.path.exists(script_path):
              print("##vso[task.logissue type=error]SQL script not found")
              print(f"##vso[task.logissue type=error]Expected path: {script_path}")
              sys.exit(1)
          
          def validate_sql_syntax(file_path):
              try:
                  with open(file_path, 'r', encoding='utf-8') as f:
                      sql_content = f.read()
                  
                  if not sql_content.strip():
                      print("##vso[task.logissue type=error]SQL file is empty")
                      return False
                  
                  parsed = sqlparse.parse(sql_content)
                  if not parsed:
                      print("##vso[task.logissue type=error]Failed to parse SQL content")
                      return False
                  
                  print("Basic SQL syntax is valid")
                  print(f"  Found {len(parsed)} SQL statement(s)")
                  return True
              except Exception as e:
                  print(f"##vso[task.logissue type=error]SQL Syntax Error: {e}")
                  return False
          
          def check_security_policies(file_path):
              with open(file_path, 'r', encoding='utf-8') as f:
                  sql_content = f.read()
              
              issues = []
              warnings = []
              
              statements = sqlparse.parse(sql_content)
              
              for i, stmt in enumerate(statements):
                  stmt_str = str(stmt).strip()
                  if not stmt_str:
                      continue
                  
                  stmt_upper = stmt_str.upper()
                  stmt_num = i + 1
                  
                  if re.search(r'\b(UPDATE|DELETE)\b', stmt_upper):
                      if not re.search(r'\bWHERE\b', stmt_upper):
                          issues.append(f"Statement {stmt_num}: {stmt_upper.split()[0]} without WHERE clause")
                  
                  dangerous_drops = ['DROP TABLE', 'DROP DATABASE', 'DROP SCHEMA']
                  for op in dangerous_drops:
                      if op in stmt_upper:
                          issues.append(f"Statement {stmt_num}: Dangerous operation - {op}")
                  
                  if 'TRUNCATE TABLE' in stmt_upper or re.search(r'\bTRUNCATE\s+TABLE\b', stmt_upper):
                      issues.append(f"Statement {stmt_num}: TRUNCATE TABLE detected")
                  
                  if 'ALTER TABLE' in stmt_upper:
                      warnings.append(f"Statement {stmt_num}: ALTER TABLE operation")
                  
                  if re.search(r'\bEXEC\s*\(|\bEXECUTE\s*\(|\bSP_EXECUTESQL\b', stmt_upper):
                      warnings.append(f"Statement {stmt_num}: Dynamic SQL detected")
              
              return issues, warnings
          
          def extract_affected_objects(file_path):
              with open(file_path, 'r', encoding='utf-8') as f:
                  sql_content = f.read()
              
              affected = {
                  'procedures': [],
                  'functions': [],
                  'views': [],
                  'tables': []
              }
              
              proc_pattern = r'(?:CREATE|ALTER|DROP)\s+PROCEDURE\s+(?:\[?[\w]+\]?\.)?\[?([\w]+)\]?'
              affected['procedures'] = re.findall(proc_pattern, sql_content, re.IGNORECASE)
              
              func_pattern = r'(?:CREATE|ALTER|DROP)\s+FUNCTION\s+(?:\[?[\w]+\]?\.)?\[?([\w]+)\]?'
              affected['functions'] = re.findall(func_pattern, sql_content, re.IGNORECASE)
              
              view_pattern = r'(?:CREATE|ALTER|DROP)\s+VIEW\s+(?:\[?[\w]+\]?\.)?\[?([\w]+)\]?'
              affected['views'] = re.findall(view_pattern, sql_content, re.IGNORECASE)
              
              table_pattern = r'(?:CREATE|ALTER|DROP)\s+TABLE\s+(?:\[?[\w]+\]?\.)?\[?([\w]+)\]?'
              affected['tables'] = re.findall(table_pattern, sql_content, re.IGNORECASE)
              
              return affected
          
          def generate_report(file_path, syntax_ok, issues, warnings, affected):
              # Use the report_dir we defined earlier
              os.makedirs(report_dir, exist_ok=True)
              report_path = os.path.join(report_dir, 'validation_report.txt')
              
              # Use UTF-8 encoding to handle special characters
              with open(report_path, 'w', encoding='utf-8') as f:
                  f.write("=" * 70 + "\n")
                  f.write("SQL VALIDATION REPORT\n")
                  f.write("=" * 70 + "\n\n")
                  f.write(f"Script: {os.path.basename(file_path)}\n")
                  f.write(f"Syntax Valid: {'YES' if syntax_ok else 'NO'}\n\n")
                  
                  if any(affected.values()):
                      f.write("AFFECTED DATABASE OBJECTS:\n")
                      f.write("-" * 70 + "\n")
                      if affected['procedures']:
                          f.write(f"  Procedures: {', '.join(set(affected['procedures']))}\n")
                      if affected['functions']:
                          f.write(f"  Functions: {', '.join(set(affected['functions']))}\n")
                      if affected['views']:
                          f.write(f"  Views: {', '.join(set(affected['views']))}\n")
                      if affected['tables']:
                          f.write(f"  Tables: {', '.join(set(affected['tables']))}\n")
                      f.write("\n")
                  
                  if issues:
                      f.write(f"CRITICAL ISSUES ({len(issues)}):\n")
                      f.write("-" * 70 + "\n")
                      for issue in issues:
                          f.write(f"  [ISSUE] {issue}\n")
                      f.write("\n")
                  
                  if warnings:
                      f.write(f"WARNINGS ({len(warnings)}):\n")
                      f.write("-" * 70 + "\n")
                      for warning in warnings:
                          f.write(f"  [INFO] {warning}\n")
                      f.write("\n")
                  
                  if not issues and not warnings:
                      f.write("No security issues detected\n\n")
                  
                  f.write("=" * 70 + "\n")
              
              affected_path = os.path.join(report_dir, 'affected_objects.json')
              with open(affected_path, 'w', encoding='utf-8') as f:
                  json.dump(affected, f, indent=2)
              
              print(f"Validation report generated: {report_path}")
          
          print(f"Validating SQL script: {script_path}\n")
          
          syntax_ok = validate_sql_syntax(script_path)
          issues, warnings = check_security_policies(script_path)
          affected = extract_affected_objects(script_path)
          
          generate_report(script_path, syntax_ok, issues, warnings, affected)
          
          if issues:
              print("\n" + "=" * 70)
              print(f"CRITICAL ISSUES FOUND ({len(issues)}):")
              print("=" * 70)
              for issue in issues:
                  print(f"  {issue}")
                  print(f"##vso[task.logissue type=error]{issue}")
              print('##vso[task.setvariable variable=hasSecurityIssues;isOutput=true]true')
          else:
              print("\nNo critical security issues found")
              print('##vso[task.setvariable variable=hasSecurityIssues;isOutput=true]false')
          
          if warnings:
              print("\n" + "=" * 70)
              print(f"WARNINGS ({len(warnings)}):")
              print("=" * 70)
              for warning in warnings:
                  print(f"  {warning}")
                  print(f"##vso[task.logissue type=warning]{warning}")
          
          if not syntax_ok:
              print("\n##vso[task.complete result=Failed;]Syntax validation failed")
              sys.exit(1)
          
          print("\nValidation completed successfully")
      env:
        PIPELINE_WORKSPACE: $(Pipeline.Workspace)
        SQL_SCRIPT_PATH: $(sqlScriptPath)

    - task: PublishPipelineArtifact@1
      displayName: 'Publish Validation Report'
      condition: always()
      inputs:
        targetPath: '$(Pipeline.Workspace)/sql'
        artifact: 'ValidationReport'
        publishLocation: 'pipeline'

- stage: Security_Review
  displayName: 'Security Review Required'
  dependsOn: Download_And_Validate
  condition: |
    and(
      succeeded(),
      eq(dependencies.Download_And_Validate.outputs['ValidateScript.SQLValidation.hasSecurityIssues'], 'true')
    )
  
  jobs:
  - job: WaitForApproval
    displayName: 'Manual Security Approval'
    pool: server
    timeoutInMinutes: 1440
    
    steps:
    
    - task: ManualValidation@1
      inputs:
        notifyUsers: 'shubh.bhanushali@g7cr.com'
        approvers: 'shubh.bhanushali@g7cr.com'
        instructions: 'Security issues detected. please check validation report in order to cancel or approve the run'
- stage: Backup_Database_Objects
  displayName: 'Backup User Database Objects'
  dependsOn: 
    - Download_And_Validate
    - Security_Review
  condition: |
    and(
      not(failed()),
      not(canceled()),
      eq('${{ parameters.enableBackup }}', 'true'),
      eq('${{ parameters.dryRun }}', 'false')
    )
  
  jobs:
  - job: CreateBackup
    displayName: 'Backup User-Created Database Objects'
    pool:
      name: ${{ parameters.agentPool }}
    timeoutInMinutes: 30
    
    steps:
    - checkout: none
    
    - task: DownloadPipelineArtifact@2
      displayName: 'Download SQL Script and Validation Results'
      inputs:
        artifact: 'ValidationReport'
        path: '$(Pipeline.Workspace)/sql'

    - task: AzurePowerShell@5
      name: BackupObjects
      displayName: 'Backup User-Generated Database Objects'
      inputs:
        azureSubscription: 'Azure-Connection'
        ScriptType: 'InlineScript'
        azurePowerShellVersion: 'LatestVersion'
        Inline: |
          $ErrorActionPreference = "Stop"
          
          try {
              Write-Host "Retrieving connection string from Key Vault..."
              $connectionString = Get-AzKeyVaultSecret -VaultName "$(keyVaultName)" -Name "$(secretName)" -AsPlainText
              
              if ([string]::IsNullOrEmpty($connectionString)) {
                  throw "Failed to retrieve connection string from Key Vault"
              }
              
              Write-Host "Reading affected objects list..."
              $affectedObjectsPath = "$(Pipeline.Workspace)/sql/affected_objects.json"
              
              if (Test-Path $affectedObjectsPath) {
                  $affectedObjects = Get-Content $affectedObjectsPath | ConvertFrom-Json
              } else {
                  Write-Host "No affected objects file found"
                  $affectedObjects = @{
                      procedures = @()
                      functions = @()
                      views = @()
                      tables = @()
                  }
              }
              
              New-Item -ItemType Directory -Force -Path '$(backupPath)' | Out-Null
              
              $timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
              $backupFile = "$(backupPath)/backup_$timestamp.sql"
              
              $backupScript = @"
          -- ============================================================
          -- DATABASE BACKUP SCRIPT (USER OBJECTS ONLY)
          -- ============================================================
          -- Generated: $(Get-Date -Format "yyyy-MM-dd HH:mm:ss")
          -- Build: $(Build.BuildNumber)
          -- Original Script: ${{ parameters.sqlScriptName }}
          -- ============================================================
          
          "@
              
              $objectsBackedUp = 0
              
              # -------------------------
              # Always backup stored procedures (changed: remove dependency on affected_objects)
              # -------------------------
              Write-Host "Backing up user-created stored procedures..."
              
              $procQuery = @"
          SELECT 
              OBJECT_SCHEMA_NAME(object_id) as SchemaName,
              name as ObjectName,
              OBJECT_DEFINITION(object_id) as Definition
          FROM sys.procedures
          WHERE is_ms_shipped = 0
            AND name NOT LIKE 'sp[_]%'
            AND name NOT LIKE 'dt[_]%'
          "@
              
              try {
                  $procedures = Invoke-Sqlcmd -ConnectionString $connectionString -Query $procQuery -MaxCharLength 65535 -ErrorAction Stop
                  
                  if ($procedures) {
                      $backupScript += "`r`n-- ========================================`r`n"
                      $backupScript += "-- STORED PROCEDURES (User Objects)`r`n"
                      $backupScript += "-- ========================================`r`n`r`n"
                      
                      foreach ($proc in $procedures) {
                          $fullName = "$($proc.SchemaName).$($proc.ObjectName)"
                          Write-Host "  Backing up procedure: $fullName"
                          
                          $backupScript += "-- Procedure: $fullName`r`n"
                          if ($proc.Definition) {
                              $backupScript += $proc.Definition + "`r`n"
                          }
                          $backupScript += "GO`r`n`r`n"
                          $objectsBackedUp++
                      }
                  }
              }
              catch {
                  Write-Warning "Failed to backup procedures: $($_.Exception.Message)"
              }
              
              # -------------------------
              # Always backup functions (changed: remove dependency on affected_objects)
              # -------------------------
              Write-Host "Backing up user-created functions..."
              
              $funcQuery = @"
          SELECT 
              OBJECT_SCHEMA_NAME(object_id) as SchemaName,
              name as ObjectName,
              OBJECT_DEFINITION(object_id) as Definition
          FROM sys.objects
          WHERE type IN ('FN', 'IF', 'TF')
            AND is_ms_shipped = 0
          "@
              
              try {
                  $functions = Invoke-Sqlcmd -ConnectionString $connectionString -Query $funcQuery -MaxCharLength 65535 -ErrorAction Stop
                  
                  if ($functions) {
                      $backupScript += "`r`n-- ========================================`r`n"
                      $backupScript += "-- FUNCTIONS (User Objects)`r`n"
                      $backupScript += "-- ========================================`r`n`r`n"
                      
                      foreach ($func in $functions) {
                          $fullName = "$($func.SchemaName).$($func.ObjectName)"
                          Write-Host "  Backing up function: $fullName"
                          
                          $backupScript += "-- Function: $fullName`r`n"
                          if ($func.Definition) {
                              $backupScript += $func.Definition + "`r`n"
                          }
                          $backupScript += "GO`r`n`r`n"
                          $objectsBackedUp++
                      }
                  }
              }
              catch {
                  Write-Warning "Failed to backup functions: $($_.Exception.Message)"
              }
              
              # -------------------------
              # Always backup views (changed: remove dependency on affected_objects)
              # -------------------------
              Write-Host "Backing up user-created views..."
              
              $viewQuery = @"
          SELECT 
              OBJECT_SCHEMA_NAME(object_id) as SchemaName,
              name as ObjectName,
              OBJECT_DEFINITION(object_id) as Definition
          FROM sys.views
          WHERE is_ms_shipped = 0
            AND name NOT LIKE 'sys%'
          "@
              
              try {
                  $views = Invoke-Sqlcmd -ConnectionString $connectionString -Query $viewQuery -MaxCharLength 65535 -ErrorAction Stop
                  
                  if ($views) {
                      $backupScript += "`r`n-- ========================================`r`n"
                      $backupScript += "-- VIEWS (User Objects)`r`n"
                      $backupScript += "-- ========================================`r`n`r`n"
                      
                      foreach ($view in $views) {
                          $fullName = "$($view.SchemaName).$($view.ObjectName)"
                          Write-Host "  Backing up view: $fullName"
                          
                          $backupScript += "-- View: $fullName`r`n"
                          if ($view.Definition) {
                              $backupScript += $view.Definition + "`r`n"
                          }
                          $backupScript += "GO`r`n`r`n"
                          $objectsBackedUp++
                      }
                  }
              }
              catch {
                  Write-Warning "Failed to backup views: $($_.Exception.Message)"
              }
              
              if ($objectsBackedUp -eq 0) {
                  Write-Host "No user objects found to backup"
                  $backupScript += "`r`n-- No user objects found to backup`r`n"
              }
              
              $backupScript | Out-File -FilePath $backupFile -Encoding UTF8
              Write-Host "Backup saved to: $backupFile"
              Write-Host "Total objects backed up: $objectsBackedUp"
              
              Write-Host "Uploading backup to Azure Storage..."
              $blobName = "backup_$(Build.BuildNumber)_$timestamp.sql"
              
              $storageAccount = Get-AzStorageAccount | Where-Object { $_.StorageAccountName -eq "$(storageAccountName)" }
              $ctx = $storageAccount.Context
              
              Set-AzStorageBlobContent `
                  -File $backupFile `
                  -Container "$(backupContainerName)" `
                  -Blob $blobName `
                  -Context $ctx `
                  -Force
              
              Write-Host "Backup completed successfully"
              Write-Host "  Objects backed up: $objectsBackedUp"
              Write-Host "  Backup location: $(backupContainerName)/$blobName"
              
              Write-Host "##vso[task.setvariable variable=backupCompleted;isOutput=true]true"
              Write-Host "##vso[task.setvariable variable=backupBlobName;isOutput=true]$blobName"
              Write-Host "##vso[task.setvariable variable=objectsBackedUp;isOutput=true]$objectsBackedUp"
          }
          catch {
              Write-Error "Backup failed: $($_.Exception.Message)"
              exit 1
          }

    - task: PublishPipelineArtifact@1
      displayName: 'Publish Backup Files'
      condition: always()
      inputs:
        targetPath: '$(backupPath)'
        artifact: 'DatabaseBackup'
        publishLocation: 'pipeline'

- stage: Execute_SQL_Script
  displayName: 'Execute SQL Script'
  dependsOn: 
    - Download_And_Validate
    - Security_Review
    - Backup_Database_Objects
  condition: |
    and(
      not(failed()),
      not(canceled()),
      eq('${{ parameters.dryRun }}', 'false')
    )
  
  jobs:
  - job: ExecuteScript
    displayName: 'Run SQL Script'
    pool:
      name: ${{ parameters.agentPool }}
    timeoutInMinutes: 60
    
    steps:
    - checkout: none
    
    - task: DownloadPipelineArtifact@2
      displayName: 'Download SQL Script'
      inputs:
        artifact: 'SQLScript'
        path: '$(Pipeline.Workspace)/sql'

    - task: AzurePowerShell@5
      name: ExecuteSQL
      displayName: 'Execute SQL Script'
      inputs:
        azureSubscription: 'Azure-Connection'
        ScriptType: 'InlineScript'
        azurePowerShellVersion: 'LatestVersion'
        Inline: |
          $ErrorActionPreference = "Stop"
          
          try {
              Write-Host "Retrieving connection string..."
              $connectionString = Get-AzKeyVaultSecret -VaultName "$(keyVaultName)" -Name "$(secretName)" -AsPlainText
              
              Write-Host "Reading SQL script..."
              $scriptContent = Get-Content -Path '$(Pipeline.Workspace)/sql/${{ parameters.sqlScriptName }}' -Raw
              
              if ([string]::IsNullOrEmpty($scriptContent)) {
                  throw "SQL script is empty"
              }
              
              New-Item -ItemType Directory -Force -Path "$(logsPath)" | Out-Null
              $logFile = "$(logsPath)/execution_log.txt"
              
              $logHeader = @"
          ========================================
          SQL SCRIPT EXECUTION LOG
          ========================================
          Build: $(Build.BuildNumber)
          Script: ${{ parameters.sqlScriptName }}
          Started: $(Get-Date -Format "yyyy-MM-dd HH:mm:ss")
          ========================================
          
          "@
              $logHeader | Out-File -FilePath $logFile -Encoding UTF8
              
              # Split into batches on lines that contain only GO (case-insensitive), coerce to array, and remove empty entries
              $statements = @($scriptContent -split '(?mi)^\s*GO\s*$') | Where-Object { $_.Trim() -ne "" }
              
              Write-Host "Found $($statements.Count) statement batch(es)"
              
              $executedCount = 0
              $totalDuration = [TimeSpan]::Zero
              
              # Use foreach over statements to avoid indexing/singular string issues
              foreach ($statement in $statements) {
                  $statement = $statement.Trim()
                  
                  if ([string]::IsNullOrWhiteSpace($statement)) {
                      continue
                  }
                  
                  $executedCountForPreview = $executedCount + 1
                  $preview = if ($statement.Length -gt 150) { $statement.Substring(0, 150) + "..." } else { $statement }
                  
                  Write-Host ""
                  Write-Host "Executing batch $executedCountForPreview of $($statements.Count)"
                  Write-Host $preview
                  
                  "Batch $executedCountForPreview - $(Get-Date -Format 'HH:mm:ss')" | Out-File -FilePath $logFile -Append
                  $preview | Out-File -FilePath $logFile -Append
                  
                  try {
                      $startTime = Get-Date
                      
                      Invoke-Sqlcmd -ConnectionString $connectionString `
                                    -Query $statement `
                                    -QueryTimeout 600 `
                                    -ErrorAction Stop
                      
                      $duration = (Get-Date) - $startTime
                      $totalDuration += $duration
                      $executedCount++
                      
                      $successMsg = "Batch $executedCountForPreview completed in $([math]::Round($duration.TotalSeconds, 2))s"
                      Write-Host $successMsg -ForegroundColor Green
                      "$successMsg`n" | Out-File -FilePath $logFile -Append
                  }
                  catch {
                      $errorMsg = "Batch $executedCountForPreview failed: $($_.Exception.Message)"
                      Write-Host $errorMsg -ForegroundColor Red
                      "$errorMsg`n" | Out-File -FilePath $logFile -Append
                      throw "SQL execution failed at batch $executedCountForPreview"
                  }
              }
              
              Write-Host ""
              Write-Host "SQL SCRIPT EXECUTED SUCCESSFULLY" -ForegroundColor Green
              Write-Host "Batches executed: $executedCount" -ForegroundColor Green
              Write-Host "Total duration: $([math]::Round($totalDuration.TotalSeconds, 2))s" -ForegroundColor Green
              
              Write-Host "##vso[task.setvariable variable=executionResult;isOutput=true]Success"
              Write-Host "##vso[task.setvariable variable=executedCount;isOutput=true]$executedCount"
              Write-Host "##vso[task.setvariable variable=totalDuration;isOutput=true]$([math]::Round($totalDuration.TotalSeconds, 2))"
          }
          catch {
              Write-Host ""
              Write-Host "SQL SCRIPT EXECUTION FAILED" -ForegroundColor Red
              Write-Host "Error: $($_.Exception.Message)" -ForegroundColor Red
              
              Write-Host "##vso[task.setvariable variable=executionResult;isOutput=true]Failed"
              Write-Host "##vso[task.logissue type=error]SQL execution failed"
              
              exit 1
          }

    - task: PublishPipelineArtifact@1
      displayName: 'Publish Execution Logs'
      condition: always()
      inputs:
        targetPath: '$(logsPath)'
        artifact: 'ExecutionLogs'
        publishLocation: 'pipeline'

- stage: Notify_And_Audit
  displayName: 'Notification and Audit'
  dependsOn: 
    - Download_And_Validate
    - Backup_Database_Objects
    - Execute_SQL_Script
  condition: always()
  
  jobs:
  - job: SendNotification
    displayName: 'Send Execution Results'
    pool:
      name: ${{ parameters.agentPool }}
    timeoutInMinutes: 10
    
    steps:
    - checkout: none
    
    - task: PowerShell@2
      displayName: 'Generate Execution Summary'
      inputs:
        targetType: 'inline'
        script: |
          $result = "$(ExecuteSQL.executionResult)"
          $buildNumber = "$(Build.BuildNumber)"
          $scriptName = "${{ parameters.sqlScriptName }}"
          $isDryRun = "${{ parameters.dryRun }}"
          
          Write-Host ""
          Write-Host "=" * 70
          Write-Host "PIPELINE EXECUTION SUMMARY"
          Write-Host "=" * 70
          Write-Host "Build Number: $buildNumber"
          Write-Host "Script Name: $scriptName"
          Write-Host "Dry Run Mode: $isDryRun"
          Write-Host "Executed By: $(Build.RequestedFor)"
          
          if ($isDryRun -eq "true") {
              Write-Host ""
              Write-Host "DRY RUN COMPLETED - VALIDATION ONLY" -ForegroundColor Cyan
          }
          elseif ($result -eq "Success") {
              Write-Host ""
              Write-Host "EXECUTION SUCCESSFUL" -ForegroundColor Green
          } else {
              Write-Host ""
              Write-Host "EXECUTION FAILED" -ForegroundColor Red
          }
          
          Write-Host "=" * 70

    - task: AzurePowerShell@5
      displayName: 'Create Audit Trail'
      condition: eq('${{ parameters.dryRun }}', 'false')
      inputs:
        azureSubscription: 'Azure-Connection'
        ScriptType: 'InlineScript'
        azurePowerShellVersion: 'LatestVersion'
        Inline: |
          $ErrorActionPreference = "Continue"
          
          try {
              $auditLog = @{
                  buildNumber = "$(Build.BuildNumber)"
                  buildId = "$(Build.BuildId)"
                  scriptName = "${{ parameters.sqlScriptName }}"
                  executionResult = "$(ExecuteSQL.executionResult)"
                  executedBy = "$(Build.RequestedFor)"
                  executedAt = (Get-Date).ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ssZ")
                  dryRun = "${{ parameters.dryRun }}"
              } | ConvertTo-Json
              
              $auditFile = "audit_$(Build.BuildNumber)_$(Get-Date -Format 'yyyyMMdd_HHmmss').json"
              $auditLog | Out-File -FilePath $auditFile -Encoding UTF8
              
              Write-Host "Audit log created: $auditFile"
              
              $storageAccount = Get-AzStorageAccount | Where-Object { $_.StorageAccountName -eq "$(storageAccountName)" }
              
              if ($storageAccount) {
                  $ctx = $storageAccount.Context
                  
                  $container = Get-AzStorageContainer -Name "audit-logs" -Context $ctx -ErrorAction SilentlyContinue
                  if (-not $container) {
                      New-AzStorageContainer -Name "audit-logs" -Context $ctx -Permission Off
                  }
                  
                  Set-AzStorageBlobContent `
                      -File $auditFile `
                      -Container "audit-logs" `
                      -Blob $auditFile `
                      -Context $ctx `
                      -Force
                  
                  Write-Host "Audit log uploaded to blob storage"
              }
          }
          catch {
              Write-Warning "Failed to create audit trail: $($_.Exception.Message)"
          }
